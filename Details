import ast  # Importing ast to safely evaluate string as list

# Function to get the category based on phrase extraction and category dictionary
def get_category(phrase_list_str):
    try:
        # Convert string to actual list
        phrase_list = ast.literal_eval(phrase_list_str)
        if isinstance(phrase_list, list) and phrase_list:  # Ensure it's a non-empty list
            first_phrase = phrase_list[0]
            for cat, keywords in category.items():
                if first_phrase in keywords:
                    return cat
    except (ValueError, SyntaxError):
        pass  # Handle cases where string is not a valid list format
    return None  # Return None if no matching category found or list is empty

# Function to check word count and update themes
def update_theme_based_on_length(row, text_field_name):
    try:
        # Calculate word count of the original text field
        total_words = len(row[text_field_name].split())
        if total_words < 80:  # Check if word count is less than 80
            return "Short Text Theme"  # Default theme for short text
    except AttributeError:
        pass
    return row['Top theme']  # Return existing Top theme if conditions not met

# Applying logic
for i, row in df.iterrows():
    if row['Top phrase similarity score'] != 1:
        # Update theme based on category match
        new_theme = get_category(row['phrase extraction'])
        # Update theme if valid category found and themes are different
        if new_theme and row['Top theme'] != row['Second top theme']:
            df.at[i, 'Top theme'] = new_theme
            df.at[i, 'Second top theme'] = new_theme

    # Update theme for short text using the original text field
    updated_theme = update_theme_based_on_length(row, 'original_text_field')
    if updated_theme != row['Top theme']:  # If updated, set both themes
        df.at[i, 'Top theme'] = updated_theme
        df.at[i, 'Second top theme'] = updated_theme

print(df)
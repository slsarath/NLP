from sentence_transformers import util

def semantic_search_mpnet(text, phrase_embeddings, phrases_list, theme_dict, top_k=3, min_similarity=0.7):
    words = text.split()
    
    # Ensure the text is sufficiently descriptive to warrant a search
    if len(words) > 1:
        text_embedding = model_mpnet.encode(text, convert_to_tensor=True)
        
        # Calculate similarity scores for each phrase
        similarity_scores = [
            util.pytorch_cos_sim(text_embedding, phrase_emb).item() for phrase_emb in phrase_embeddings
        ]
        
        # Filter indices based on minimum similarity threshold
        top_indices = sorted(
            [i for i, score in enumerate(similarity_scores) if score >= min_similarity],
            key=lambda i: similarity_scores[i],
            reverse=True
        )
        
        top_phrases = []
        seen_themes = set()
        
        # Select top_k phrases that meet the theme uniqueness condition
        for i in top_indices:
            if len(top_phrases) >= top_k:
                break
                
            phrase = phrases_list[i]
            theme = theme_dict.get(phrase)
            
            # Ensure each theme is unique within top_k results
            if theme and theme not in seen_themes:
                top_phrases.append((phrase, similarity_scores[i]))
                seen_themes.add(theme)
        
        # Return only top_k results or an empty list if none met criteria
        return top_phrases if top_phrases else []
    
    return []
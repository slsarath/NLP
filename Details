WITH ordered_lines AS (
  SELECT
    ca.customermetadata_contactid AS contact_id,
    CONCAT(
      CASE
        WHEN tagname LIKE '%ParticipantId%' THEN 'AParticipantId'
        ELSE SPLIT(tagname, '_')[0]
      END,
      ': ',
      tagvalue
    ) AS line,
    CAST(SPLIT(tagname, '_')[1] AS INT) AS order_number
  FROM e_awsconnect_db.cl_custm_attr ca
  WHERE
    ca.customermetadata_contactid IN (
      -- 🔁 Paste up to ~500 contact IDs here, comma-separated and single-quoted
      '88541c4e-5bac-4f5a-ba01-2d82b02052a2',
      '8d838fea-92df-4407-bdod-a26e1435435d',
      '6b5ff163-7489-4bb4-a5bd-dd1d019171e0'
      -- ...
    )
    AND (
      tagname LIKE '%_Content%' OR tagname LIKE '%ParticipantId%'
    )
    AND tagname NOT LIKE 'Participants%'
),
aggregated_transcripts AS (
  SELECT
    contact_id,
    SORT_ARRAY(COLLECT_LIST(CONCAT_WS('~', LPAD(order_number, 5, '0'), line))) AS ordered_lines
  FROM ordered_lines
  GROUP BY contact_id
)
SELECT
  contact_id,
  CONCAT_WS('\n', TRANSFORM(ordered_lines, x -> SPLIT(x, '~')[1])) AS call_transcript
FROM aggregated_transcripts;


Absolutely. Let me walk you through the query step by step — short, clear, and focused on what each part does.

⸻

🎯 Goal:

Reconstruct the full transcript for each contact_id by:
	•	Getting all the lines spoken (from multiple rows)
	•	Keeping the correct order (based on tag name)
	•	Merging them into one single string (one row per call)

⸻

🧱 Query Breakdown

🔹 1. WITH ordered_lines AS (...)

This is your base data prep.

SELECT
  ca.customermetadata_contactid AS contact_id,
  CONCAT(
    CASE
      WHEN tagname LIKE '%ParticipantId%' THEN 'AParticipantId'
      ELSE SPLIT(tagname, '_')[0]
    END,
    ': ',
    tagvalue
  ) AS line,
  CAST(SPLIT(tagname, '_')[1] AS INT) AS order_number

What it does:
	•	Pulls each row of transcript (one spoken line)
	•	Labels it as either Agent: or Customer: (based on tagname)
	•	Adds a number (extracted from tagname like Customer_Content_1) to know the sequence

So now, for each contact ID, you’ve got:
	•	Who said it (Agent/Customer)
	•	What they said (tagvalue)
	•	In what order (order_number)

⸻

🔹 2. aggregated_transcripts AS (...)

Now we group by each contact_id and collect the ordered lines.

SELECT
  contact_id,
  SORT_ARRAY(COLLECT_LIST(CONCAT_WS('~', LPAD(order_number, 5, '0'), line))) AS ordered_lines

What it does:
	•	Combines all lines for a call into a list
	•	Pads the order number (LPAD(order_number, 5, '0')) to make sure sorting works alphabetically
	•	Joins the order + line using ~ (so we can split it back later)
	•	Sorts the list by the order number

Now you have:

['00001~Customer: Hello', '00002~Agent: Hi there', ...]


⸻

🔹 3. Final SELECT Block

This flattens the transcript into a readable string:

SELECT
  contact_id,
  CONCAT_WS('\n', TRANSFORM(ordered_lines, x -> SPLIT(x, '~')[1])) AS call_transcript

What it does:
	•	For each item in the list like 00001~Customer: Hello, it splits on ~ and takes only the line
	•	Joins all those lines using newline \n

Result:

Customer: Hello
Agent: Hi there
Customer: I need help with my account
...


⸻

🧾 Final Output:

contact_id	call_transcript
abc123	Customer: Hello\nAgent: Hi there\n…

Each contact ID has its full conversation, in order, with speaker labels.

⸻

Let me know if you want a version that excludes ParticipantId lines or if your tag naming logic is slightly different.

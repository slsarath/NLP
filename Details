from sentence_transformers import util

def semantic_search_hybrid(text, phrase_embeddings, phrases_list, top_k=5, min_similarity=0.1, boost_factor=0.15):
    # Encode the input text
    text_embedding = model_mpnet.encode(text, convert_to_tensor=True)
    similarity_scores = []
    
    # Split text into lowercased words for keyword matching
    text_words = set(text.lower().split())
    
    # Iterate over phrases to calculate similarity and check keyword matches
    for i, phrase in enumerate(phrases_list):
        # Calculate semantic similarity score
        phrase_embedding = phrase_embeddings[i]
        semantic_similarity = util.pytorch_cos_sim(text_embedding, phrase_embedding).item()
        
        # Check for keyword match (at least one word in common)
        phrase_words = set(phrase.lower().split())
        keyword_match = any(word in text_words for word in phrase_words)
        
        # Boost the score if there's a keyword match
        final_score = semantic_similarity + (boost_factor if keyword_match else 0.0)
        
        # Only consider results above a minimum similarity threshold
        if final_score >= min_similarity:
            similarity_scores.append((i, final_score))
    
    # Sort by final score in descending order
    sorted_scores = sorted(similarity_scores, key=lambda x: x[1], reverse=True)
    
    # Get top phrases based on sorted scores
    top_phrases = [(phrases_list[idx], score) for idx, score in sorted_scores[:top_k]]
    
    # Return top phrases or the closest results if no high scores found
    return top_phrases if top_phrases else [("No strong match found", min_similarity)]
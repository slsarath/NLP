WITH ordered_lines AS (
  SELECT
    ca.customermetadata_contactid AS contact_id,
    CONCAT(
      CASE
        WHEN tagname LIKE '%ParticipantId%' THEN 'AParticipantId'
        ELSE SPLIT(tagname, '_')[0]
      END,
      ': ',
      tagvalue
    ) AS line,
    CAST(SPLIT(tagname, '_')[1] AS INT) AS order_number
  FROM e_awsconnect_db.cl_custm_attr ca
  WHERE
    ca.customermetadata_contactid IN (
      -- ðŸ” Paste up to ~500 contact IDs here, comma-separated and single-quoted
      '88541c4e-5bac-4f5a-ba01-2d82b02052a2',
      '8d838fea-92df-4407-bdod-a26e1435435d',
      '6b5ff163-7489-4bb4-a5bd-dd1d019171e0'
      -- ...
    )
    AND (
      tagname LIKE '%_Content%' OR tagname LIKE '%ParticipantId%'
    )
    AND tagname NOT LIKE 'Participants%'
),
aggregated_transcripts AS (
  SELECT
    contact_id,
    SORT_ARRAY(COLLECT_LIST(CONCAT_WS('~', LPAD(order_number, 5, '0'), line))) AS ordered_lines
  FROM ordered_lines
  GROUP BY contact_id
)
SELECT
  contact_id,
  CONCAT_WS('\n', TRANSFORM(ordered_lines, x -> SPLIT(x, '~')[1])) AS call_transcript
FROM aggregated_transcripts;


Absolutely. Let me walk you through the query step by step â€” short, clear, and focused on what each part does.

â¸»

ðŸŽ¯ Goal:

Reconstruct the full transcript for each contact_id by:
	â€¢	Getting all the lines spoken (from multiple rows)
	â€¢	Keeping the correct order (based on tag name)
	â€¢	Merging them into one single string (one row per call)

â¸»

ðŸ§± Query Breakdown

ðŸ”¹ 1. WITH ordered_lines AS (...)

This is your base data prep.

SELECT
  ca.customermetadata_contactid AS contact_id,
  CONCAT(
    CASE
      WHEN tagname LIKE '%ParticipantId%' THEN 'AParticipantId'
      ELSE SPLIT(tagname, '_')[0]
    END,
    ': ',
    tagvalue
  ) AS line,
  CAST(SPLIT(tagname, '_')[1] AS INT) AS order_number

What it does:
	â€¢	Pulls each row of transcript (one spoken line)
	â€¢	Labels it as either Agent: or Customer: (based on tagname)
	â€¢	Adds a number (extracted from tagname like Customer_Content_1) to know the sequence

So now, for each contact ID, youâ€™ve got:
	â€¢	Who said it (Agent/Customer)
	â€¢	What they said (tagvalue)
	â€¢	In what order (order_number)

â¸»

ðŸ”¹ 2. aggregated_transcripts AS (...)

Now we group by each contact_id and collect the ordered lines.

SELECT
  contact_id,
  SORT_ARRAY(COLLECT_LIST(CONCAT_WS('~', LPAD(order_number, 5, '0'), line))) AS ordered_lines

What it does:
	â€¢	Combines all lines for a call into a list
	â€¢	Pads the order number (LPAD(order_number, 5, '0')) to make sure sorting works alphabetically
	â€¢	Joins the order + line using ~ (so we can split it back later)
	â€¢	Sorts the list by the order number

Now you have:

['00001~Customer: Hello', '00002~Agent: Hi there', ...]


â¸»

ðŸ”¹ 3. Final SELECT Block

This flattens the transcript into a readable string:

SELECT
  contact_id,
  CONCAT_WS('\n', TRANSFORM(ordered_lines, x -> SPLIT(x, '~')[1])) AS call_transcript

What it does:
	â€¢	For each item in the list like 00001~Customer: Hello, it splits on ~ and takes only the line
	â€¢	Joins all those lines using newline \n

Result:

Customer: Hello
Agent: Hi there
Customer: I need help with my account
...


â¸»

ðŸ§¾ Final Output:

contact_id	call_transcript
abc123	Customer: Hello\nAgent: Hi there\nâ€¦

Each contact ID has its full conversation, in order, with speaker labels.

â¸»

Let me know if you want a version that excludes ParticipantId lines or if your tag naming logic is slightly different.

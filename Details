We’re analyzing how long each ID remains in a specific status before it changes — and for better accuracy, we’re only counting working days (Monday to Friday). This gives us a realistic view of where delays or bottlenecks are occurring in the process.

Here’s a quick breakdown of the logic used in the code:
	1.	Data Preparation:
	•	We start with three columns: ID, Status, and Change Date.
	•	We first ensure that Change Date is properly converted to a date format and sort all records by ID and date.
	2.	Identifying Status Transitions:
	•	For each record, we compare the current Status to the next row’s Status using .shift(-1).
	•	We also capture the Change Date of the next row.
	•	If the status changes, that means the issue has moved to a new stage — so we want to calculate how long it was in the previous status.
	3.	Calculating Working Days:
	•	We use np.busday_count() to calculate the number of working days between the current row’s Change Date and the next one.
	•	This value is assigned to a new column: Days in Status.
	•	If the status remains the same in the next row, or the date is missing, we skip the calculation.
	4.	Clean-Up:
	•	Finally, we drop the helper columns (Next Status, Next Date) to keep the output clean.

⸻

How This Feeds into the MI:

Using this cleaned dataset, we then created a pivot table to provide MI that answers key questions like:
	•	Which statuses are consuming the most working days?
	•	Which IDs are stuck the longest in a particular status?
	•	What’s the average time spent per status across all records?

We also explored visual summaries such as:
	•	A heatmap showing aging across statuses
	•	A summary of top 10 IDs stuck longest
	•	Status performance trend over time (optional)

This allows us to highlight where operational delays are occurring and identify process improvement opportunities.

Let me know if you’d like to see this built into a dashboard or exported as an Excel template.